# Podman Pod Configuration for DevOps Portfolio
# Usage: podman play kube devops-portfolio-pod.yaml
#
# This creates a single pod with three containers:
# - PostgreSQL database
# - Node.js backend API
# - NGINX frontend
#
# All containers share the same network namespace (can communicate via localhost)

apiVersion: v1
kind: Pod
metadata:
  name: devops-portfolio
  labels:
    app: devops-portfolio
spec:
  # Shared network namespace - all containers can talk via localhost
  hostNetwork: false

  containers:
  # PostgreSQL Database Container
  - name: postgres
    image: postgres:15-alpine
    env:
    - name: POSTGRES_DB
      value: devops_portfolio
    - name: POSTGRES_USER
      value: dbadmin
    - name: POSTGRES_PASSWORD
      value: securepassword123
    ports:
    - containerPort: 5432
      hostPort: 5433  # Exposed on host as 5433 to avoid conflicts
    volumeMounts:
    - name: postgres-data
      mountPath: /var/lib/postgresql/data
    - name: postgres-init
      mountPath: /docker-entrypoint-initdb.d/init.sql
      subPath: init.sql
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"

  # Backend API Container
  - name: backend
    image: localhost/docker-backend:latest
    env:
    - name: PORT
      value: "3000"
    - name: NODE_ENV
      value: development
    - name: DB_HOST
      value: localhost  # Same pod, different container
    - name: DB_PORT
      value: "5432"
    - name: DB_NAME
      value: devops_portfolio
    - name: DB_USER
      value: dbadmin
    - name: DB_PASSWORD
      value: securepassword123
    ports:
    - containerPort: 3000
      hostPort: 3001  # Exposed on host as 3001
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"

  # Frontend NGINX Container
  - name: frontend
    image: localhost/docker-frontend:latest
    env:
    - name: BACKEND_URL
      value: "http://localhost:3000"
    ports:
    - containerPort: 80
      hostPort: 8081  # Exposed on host as 8081
    volumeMounts:
    - name: frontend-nginx-config
      mountPath: /etc/nginx/conf.d/nginx.conf
      subPath: nginx.conf
    resources:
      requests:
        memory: "128Mi"
        cpu: "50m"
      limits:
        memory: "256Mi"
        cpu: "250m"

  # Volumes
  volumes:
  - name: postgres-data
    persistentVolumeClaim:
      claimName: postgres-data-pvc
  - name: postgres-init
    configMap:
      name: postgres-init-config
  - name: frontend-nginx-config
    configMap:
      name: frontend-nginx-config

---
# Persistent Volume Claim for PostgreSQL data
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
# ConfigMap for PostgreSQL initialization script
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init-config
data:
  init.sql: |
    -- Database initialization script
    -- Creates tables and initial data for the application

    -- Create items table
    CREATE TABLE IF NOT EXISTS items (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    -- Create index on created_at for sorting
    CREATE INDEX IF NOT EXISTS idx_items_created_at ON items(created_at DESC);

    -- Insert sample data
    INSERT INTO items (name, description) VALUES
        ('AWS EC2', 'Elastic Compute Cloud - Virtual servers in the cloud'),
        ('AWS S3', 'Simple Storage Service - Object storage service'),
        ('AWS ECS', 'Elastic Container Service - Container orchestration'),
        ('AWS EKS', 'Elastic Kubernetes Service - Managed Kubernetes'),
        ('Jenkins', 'CI/CD automation server'),
        ('Terraform', 'Infrastructure as Code tool'),
        ('Docker', 'Container platform'),
        ('SonarQube', 'Code quality and security analysis'),
        ('Trivy', 'Container security scanner'),
        ('OWASP ZAP', 'Web application security scanner')
    ON CONFLICT DO NOTHING;

    -- Create function to update updated_at timestamp
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = CURRENT_TIMESTAMP;
        RETURN NEW;
    END;
    $$ language 'plpgsql';

    -- Create trigger for updated_at
    DROP TRIGGER IF EXISTS update_items_updated_at ON items;
    CREATE TRIGGER update_items_updated_at
        BEFORE UPDATE ON items
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();

---
# ConfigMap for NGINX configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-nginx-config
data:
  nginx.conf: |
    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;

        # Gzip compression
        gzip on;
        gzip_vary on;
        gzip_min_length 10240;
        gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json;

        # Health check endpoint
        location /health {
            access_log off;
            try_files /health.html =200;
        }

        # Proxy API requests to backend
        # In a Podman pod, all containers share the same network namespace
        # So backend is accessible via localhost:3000
        location /api/ {
            proxy_pass http://localhost:3000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # Serve static files
        location / {
            try_files $uri $uri/ /index.html;
        }

        # Cache static assets
        location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # Deny access to hidden files
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }
    }
